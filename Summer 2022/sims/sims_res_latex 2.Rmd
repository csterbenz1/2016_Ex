---
title: "Kpop Simulation Results"
output: pdf_document
header-includes:
  - \usepackage{graphicx}
  - \usepackage{booktabs}
  - \usepackage{makecell}
  - \usepackage{xcolor}
---

```{r libs, include =F, message=FALSE, warning= F}
suppressMessages(library(tidyverse))
library(parallel)
suppressMessages(library(knitr))
library(survey)
```

```{r filenames, include = F}
r33_file = "~/Documents/Cloud Documents/Hazlett:Hartman RA/2016 Election/2016_Ex/Summer 2022/sims/noscale_res_kpopTRUE_noise1.414_on2022-11-16_nsims494.RData"
r66_file = "~/Documents/Cloud Documents/Hazlett:Hartman RA/2016 Election/2016_Ex/Summer 2022/sims/noscale_res_kpopTRUE_noise0.707_on2022-11-16_nsims494.RData"
r66_bern_file = "~/Documents/Cloud Documents/Hazlett:Hartman RA/2016 Election/2016_Ex/Summer 2022/sims/noscale_res_kpopTRUE_noise0.707_on_bernTRUE_2022-11-16_nsims494.RData"
```


```{r functions, include = F}
coverage <- function(SE, x_bar, truth =NULL, crit_val= qnorm(0.975)) {
    if(is.null(truth)) {
        truth = svymean(~outcome, cces_svy)[1]
    }
    x_upper = x_bar +  (SE*crit_val)
    x_lower = x_bar - (SE*crit_val)
    contains_truth = matrix(NA, ncol = ncol(SE), nrow = 1)
    for(i in 1:ncol(x_upper)) {
        contains_truth[,i] = sum((truth <= x_upper[,i] & truth >= x_lower[,i]))/nrow(SE)
    }
    colnames(contains_truth) = colnames(x_bar)
    return(contains_truth)
}

# eval coverage of diff SEs
all_SE_coverage <- function(sims, drop_NA = F, truth = NULL, methods = c("rake|kpop")) {
    est <- lapply(sims, `[[`, 1) %>% bind_rows()
    SEs <- lapply(sims, `[[`, 2) %>% bind_rows()
    if(drop_NA) {
        est_temp = na.omit(est)
        n_drop = nrow(est) - nrow(est_temp)
        est = est_temp
        SEs = na.omit(SEs)
    }
    
    est_c = est[grepl(methods, colnames(est))]
    SE_fixed = SEs[grepl("SE_fixed$", colnames(SEs))]
    SE_linear = SEs[grepl("SE_linear$", colnames(SEs))]
    SE_quasi = SEs[grepl("SE_quasi$", colnames(SEs))]
    SE_chad= SEs[grepl("SE_chad$", colnames(SEs))]
    
    SE_svy= SEs[grepl("SVY", colnames(SEs))]
    if(ncol(SE_svy) != 0){
        #just making sure we're getting the estimates for the same SEs that we output from svy obj which currently is demos_noedu
        search = gsub("_se_SVY","", colnames(SE_svy))
        grepl(search, colnames(est_c))
        s = coverage(SE_svy, est_c[,grepl(search, colnames(est_c))])
        s1 = rep(NA, ncol(SE_fixed))
        s1[grepl(search, colnames(est_c))] = s
        #colnames(s1) = colnames(SE_fixed)
        coverage_out = rbind(coverage(SE_fixed, est_c, truth = truth),
                             coverage(SE_linear, est_c, truth = truth),
                             coverage(SE_quasi, est_c,truth = truth),
                             coverage(SE_chad,est_c,truth = truth), 
                             s1)
        rownames(coverage_out) = c("SE_fixed", "SE_linear", "SE_quasi", "SE_chad", "SE_svy")
    } else {
        coverage_out = rbind(coverage(SE_fixed, est_c, truth = truth),
                             coverage(SE_linear, est_c, truth = truth),
                             coverage(SE_quasi, est_c,truth = truth),
                             coverage(SE_chad,est_c,truth = truth))
        rownames(coverage_out) = c("SE_fixed", "SE_linear", "SE_quasi", "SE_chad")
    }
    
    
    if(drop_NA) {
        out = list()
        out$n_drop = n_drop
        out$coverage = coverage_out
    } else {
        out = coverage_out
    }
    return(out)
}

```



```{r outcome, include = F}
###### SET PARAMS  ###############
make_outcome <- function(noise, bern = F, selection_coefs = NULL, outcome_coefs = NULL, POPW = FALSE, 
                         coverage_eval = TRUE) {
    set.seed(9345876)
    if(detectCores() > 10) {
      path_data = "/home/csterbenz/Data/"
      cores_saved = 10
    } else if(detectCores() != 4) {
      path_data= "/Users/Ciara_1/Dropbox/kpop/Updated/application/data/"
      cores_saved = 6
    } else {
        path_data= "/Users/Ciara/Dropbox/kpop/Updated/application/data/"
        cores_saved = 2
    }
    TEST = FALSE
    tolerance = 1e-4
    maxit = 500
    #both for runtime
    increment = 5
    min_num_dims = NULL
    max_num_dims = NULL
    ##### Central Params to adjust
    simple_selection_model = TRUE
    ###################### Formulas ################
    formula_rake_demos_noeduc <- ~recode_age_bucket + recode_female + recode_race +
      recode_region + recode_pid_3way
    
    #updated to include 6 way edu
    formula_rake_demos_weduc <- ~recode_age_bucket + recode_female +
      recode_race + recode_region + recode_educ + recode_pid_3way
    
    formula_rake_all_vars <- ~recode_age_bucket + recode_female +
      recode_race + recode_region + recode_pid_3way + recode_educ +
      recode_income_5way + recode_relig_6way + recode_born + recode_attndch_4way
    
    formula_ps <- ~recode_age_3way + recode_female + recode_race +
      recode_region + recode_educ_wh_3way + recode_pid_3way
    
    if(coverage_eval) {
        formula_ps <- ~recode_age_3way + recode_female + recode_pid_3way
    }
    
    formula_ps_reduc <- ~recode_age_3way + recode_female +
      recode_race + recode_region + recode_pid_3way  +
      recode_income_3way + recode_born + recode_educ_wh_3way
    
    # #let's coarsen income and religion and attend church for all:
    formula_ps_all <- ~recode_age_3way + recode_female +
      recode_race + recode_region + recode_pid_3way + recode_educ_3way +
      recode_income_3way + recode_relig_6way + recode_born + recode_attndch_bin
    
    create_targets <- function (target_design, target_formula) {
      target_mf <- model.frame(target_formula, model.frame(target_design))
      target_mm <- model.matrix(target_formula, target_mf)
      wts <- weights(target_design)
    
      return(colSums(target_mm * wts) / sum(wts))
    }
    
    manual_rescale <- function(dat, a =0, b= 1) {
        rescaled = (b-a)*( dat - min(dat))/(max(dat) - min(dat)) + a
        return(rescaled)
    }
    
    ### Post-stratification function
    ## For now assumes that strata variable is already created and in
    ## the data set and called "strata"
    postStrat <- function(survey, pop_counts, pop_w_col, strata_pass) {
      survey_counts <- survey %>%
        group_by(!!as.symbol(strata_pass)) %>%
        summarize(n = n()) %>%
        ungroup() %>%
        mutate(w_survey = n / sum(n))
    
      pop_counts <- pop_counts %>%
        rename(w_pop = matches(pop_w_col))
    
      post_strat <- pop_counts %>%
        left_join(survey_counts, by = strata_pass) %>%
        filter(!is.na(w_survey)) %>%
        ## Normalizes back to 1 after dropping
        ## empty cells
        mutate(w_pop = w_pop * 1/sum(w_pop),
               w = w_pop / w_survey) %>%
        dplyr::select(!!as.symbol(strata_pass), w)
    
      survey <- survey %>%
        left_join(post_strat)
    
      return(survey)
    }
    
    
    ############# Load Data #####################
    #these data have been cleaned already see app_modeled for how it was done
    ## Load Pew
    pew <- readRDS(paste0(path_data, "pew_lasso_061021.rds"))
    ### Load Target Data
    cces <- readRDS(paste0(path_data, "cces_lasso_061021.rds"))
    ######### Make STRATA variable in CCES and Pew ############
    cces <- bind_cols(cces, cces %>%
                        unite("strata", all.vars(formula_ps), remove = FALSE) %>%
                        unite("strata_reduc", all.vars(formula_ps_reduc),
                              remove = FALSE) %>%
                        unite("strata_all", all.vars(formula_ps_all)) %>%
                        dplyr::select(strata, strata_reduc, strata_all))
    #weirdly this is producing still bias w ps on the correct formula apparently maybe because we are dropping the one category  with unite so im going to try this manual way:
    cces = cces %>% mutate(strata = paste(recode_pid_3way,recode_female, recode_age_bucket, sep = "_"))
    
    pew <- bind_cols(pew, pew %>%
                       unite("strata", all.vars(formula_ps), remove = FALSE) %>%
                       unite("strata_reduc", all.vars(formula_ps_reduc),
                             remove = FALSE) %>%
                       unite("strata_all", all.vars(formula_ps_all)) %>%
                       dplyr::select(strata, strata_reduc, strata_all))
    
    pew = pew %>% mutate(strata = paste(recode_pid_3way, recode_female, recode_age_bucket, sep = "_"))
    
    
     ##################### LASSO: Selection #############################
    
    #income, religion, pid x race
    if(!coverage_eval) {
    
        if(simple_selection_model) {
            #first attempt to make this worse
            selection_model = as.formula(~recode_pid_3way:poly(recode_age, 2) +
                                             recode_female:recode_pid_3way)
            #first attempt to make this worse
            #center age then square
            pew = pew %>% mutate(centered_age = scale(recode_age, scale = F))
            cces = cces %>% mutate(centered_age = scale(recode_age, scale = F))
    
            selection_model = as.formula(~recode_pid_3way*poly(centered_age, 2) +
                                             #recode_age:recode_pid_3way +
                                             recode_female*recode_pid_3way)
    
            #selection_model = as.formula(~recode_pid_3way + recode_age_bucket + recode_female)
    
        } else {
            selection_model = as.formula(~recode_female:recode_pid_3way +
                                             recode_age:recode_pid_3way +
                                             #adds a bit mroe bias to edu+d
                                             recode_pid_race +
                                             recode_race_reg_wh_educ +
                                             recode_educ_wh_3way +
                                             poly(recode_age, 3))
        }
    
        # Stack data with S = 1 indicating Pew
        stack_data <- data.frame(bind_rows(pew, cces),
                                 S = c(rep(1, nrow(pew)), rep(0, nrow(cces))))
    
    
        mod <- model.matrix(selection_model, data = stack_data)
        nrow(mod)
        ## Remove columns where Pew missing strata
        ncol(mod)
        mod <- mod[, apply(mod[stack_data$S == 1, ], 2, sum) != 0]
        ## Remove columns where CCES missing Strata
        mod <- mod[, apply(mod[stack_data$S == 0, ], 2, sum) != 0]
        ncol(mod)
        lasso_lambda <- cv.glmnet(x= mod[,-1],
                                  y = as.matrix(stack_data$S),
                                  alpha = 1,
                                  family = "binomial",
                                  intercept = TRUE)
        lasso_lambda$lambda.min
        lasso_include <- glmnet(x= mod[,-1],
                                y = as.matrix(stack_data$S),
                                alpha = 1,
                                lambda = lasso_lambda$lambda.min,
                                weights = if(POPW){ c(rep(1, nrow(pew)),
                                                      cces$commonweight_vv_post)} else {NULL},
                                family = "binomial",
                                intercept = TRUE)
    
        lasso_include_coefs <- coef(lasso_include)
        res <- as.matrix(lasso_include_coefs)
        ncol(mod)
        sum(lasso_include_coefs == 0)
        lasso_pinclude = predict(lasso_include,
                                 s= lasso_lambda$lambda.min,
                                 type = "response",
                                 newx = mod[stack_data$S == 0,-1])
    
        p_include <- lasso_pinclude
    
        ########### Sampling Inclusion Results
        summary(p_include)
        p_include_raw = p_include
        intercept_shift = 0
        p_include = p_include*(n_sample/sum(p_include)) + intercept_shift
    
        #################### Define Outcome #########
        cces$outcome = cces$diff_cces_on_cces
    } else {
    
        ########## DESIGN SELECTION MODEL: Specifying Coefs Directly
        #coefs: pid, age, gender
        selection_model = as.formula(~recode_pid_3way + recode_age_bucket + recode_female)
        cces_expanded = model.matrix(selection_model, data = cces)
        #needs to be n x p X p x 1 -> coef matrix is p x 1
        coefs = matrix(NA,nrow = ncol(cces_expanded), ncol =1 )
        rownames(coefs) = colnames(cces_expanded)
        if(is.null(selection_coefs)) {
            coefs[,1] = c(-5.2, #intercept
                      .1, #selection of indep pos
                      .4, #selection of R pos
                      .1, #36-50,
                      .3, #51-64,
                      .8, #65+,
                      .4 #male pos
                      )
        } else {
            coefs = selection_coefs
        }
        
        selection_coefs_kable = data.frame(coefs)
        colnames(selection_coefs_kable) = "Coefficient Value"
        rownames(selection_coefs_kable) = gsub("^recode_", "", rownames(selection_coefs_kable))
        selection_coefs_kable = kable(selection_coefs_kable,
                                          format = "latex", booktabs = T,
                           caption = "Selection Model" )
        
        xbeta = cces_expanded %*% coefs
        p_include = plogis(xbeta)
        cat(paste("Sum of Selection Probs is:", round(sum(p_include), 3), "\n"))
        out = c(min(p_include), 
                quantile(p_include, c(0.25, 0.5, .75)), 
                max(p_include), 
                sum(p_include))
        out = as.matrix(out)
        rownames(out) =  c("Min", "25%", "Mean", "75%", "Max", "Sum")
        colnames(out) = c("Selection Probability")
        
        prob_kable = kable(round(out, 4), format = "latex", 
                           booktabs = T,
                           caption = "Sample Inclusion Probabilities")
        
        #11/9 update: moving to probabiltiy scale with outcome only p(D) approx .5
        coefs_outcome = coefs
        if(is.null(outcome_coefs)) {
            coefs_outcome[,1] = c(6.1, #intercept
                              -.3, #  indep pos #decreasing lowers mean, increases corr #try 1
                              -1.1, #  R pos #empirically
                              -.2 ,#36-50, #empirically in cces lean dem 50% #.55
                              -.3, #51-64, #empirically lean rep slightly 50%
                              -.7, #65+, #empirically lean rep 51%
                              #base cat: 18-35 lean strongly dem 58%
                              -.7 #male #empirically women lean dem 53%
            )
            coefs_outcome = coefs_outcome/10
        } else {
            coefs_outcome = outcome_coefs
        }
        
        coefs_outcome_kable = data.frame(coefs_outcome)
        colnames(coefs_outcome_kable) = "Coefficient Value"
        rownames(coefs_outcome_kable) = gsub("^recode_", "", rownames(coefs_outcome_kable))
        coefs_outcome_kable = kable(coefs_outcome_kable,
                                          format = "latex", booktabs = T,
                           caption = "Outcome Model" )
        
        xbeta_outcome = cces_expanded %*% coefs_outcome
        #cat(paste("Orig mean scaled outcome", round(mean(xbeta_outcome)*100, 3) , "\n"))
        #summary(xbeta_outcome)
        cat(paste("Adding sd(outcome)*",noise, "\n"))
        xbeta_outcome = xbeta_outcome + rnorm(nrow(cces), mean = 0, sd = sd(xbeta_outcome)*noise)
        # summary(xbeta_outcome)
        # cor(xbeta_outcome, p_include)
        # cces[which(xbeta_outcome == min(xbeta_outcome)),
        #      c("recode_pid_3way", "recode_age_bucket", "recode_female" )]
        # cces[which(xbeta_outcome == max(xbeta_outcome)),
        #      c("recode_pid_3way", "recode_age_bucket", "recode_female" )]
    
        #plot(density(xbeta_outcome))
        #cat(paste("Mean outcome w/noise is", round(mean(xbeta_outcome)*100,3), "\n"))
        if(bern) {xbeta_outcome = rbinom(nrow(cces), 1, xbeta_outcome) }
        cat(paste("Range of outcome w/noise is\n"))
        cat(paste(summary(xbeta_outcome), "\n"))
        s = summary(lm(xbeta_outcome ~ recode_pid_3way + recode_age_bucket + recode_female, 
                       data = cces))
        R2_outcome = s$adj.r.squared
        cat(paste("R^2 outcome is", round(s$adj.r.squared,3), "\n"))
        cat(paste("Mean scaled outcome (target) is", round(mean(xbeta_outcome)*100,3)))
        cat(paste("\nCorr of sampling prob and outcome ", round(cor(xbeta_outcome, p_include),3)))
        #bernoulli draw
        cces$outcome = xbeta_outcome
    }
    
    #################### Targets ###################
    if(POPW) {
      cces_svy <- svydesign(ids = ~1, weights = ~commonweight_vv_post, data = cces)
    } else {
      cces_svy <- svydesign(ids = ~1, data = cces)
    }
    return(list(R2 = R2_outcome,
                target = mean(cces$outcome),
                corr = cor(xbeta_outcome, p_include), 
                selection_prob_kable = prob_kable,
                coefs_outcome_kable= coefs_outcome_kable, 
                selection_coefs_kable= selection_coefs_kable))
}

r33 = make_outcome(noise = sqrt(2))
r66 =  make_outcome(noise = sqrt(2)*(1/2))
r66_bern = make_outcome(noise = sqrt(2)*(1/2), bern = T)
```

```{r emp_SEs, include = F}
empirical_SEs <- function(sims, eval_kpop = T, return_svy_package = F) {
    SEs = lapply(sims, `[[`, 2) %>% bind_rows()
    est <- lapply(sims, `[[`, 1) %>% bind_rows()
    cols = if(eval_kpop) { c(3:7,10:12,14:19)} else {c(3:7,10:12)}
    est =est[, cols]
    
    #avg SEs
    avg_SE = colMeans(SEs)
    avg_SE_out = rbind(avg_SE[grepl("SE_fixed$", names(avg_SE))],
                   avg_SE[grepl("SE_linear$", names(avg_SE))],
                   avg_SE[grepl("SE_quasi$", names(avg_SE))],
                   avg_SE[grepl("SE_chad", names(avg_SE))],
                   avg_SE[grepl("SVY", names(avg_SE))])
    rownames(avg_SE_out) = c("SE_fixed", "SE_linear", "SE_quasi", "SE_chad", "SE_SVY") 
    colnames(avg_SE_out) = gsub("_SE_fixed", "", colnames(avg_SE_out))
    
    #bootstrapped SEs
    boot_SE = t(as.matrix(apply(est, 2, sd)))
    SE_boot = boot_SE[, colnames(boot_SE) %in% colnames(avg_SE_out)]
    emp_SEs = rbind(avg_SE_out, SE_boot)
    
    if(!return_svy_package) {
        avg_SE_out = avg_SE_out[-which(rownames(avg_SE_out) == "SE_SVY"), ]
        emp_SEs = emp_SEs[-which(rownames(emp_SEs) == "SE_SVY"), ]
    }
    
    return(list(emp_SEs =emp_SEs, 
                boot_SE = boot_SE,
                avg_SE = avg_SE_out) )    
}

```


# Simulation Set Up

$$p(S=1) = logit^{-1}\Big( PID(3 way) + Age(4way)+ Gender  \Big)$$

More specifically:
$$p(S=1) = logit^{-1}\Big( \alpha + \beta_1 Indep + \beta_2 Rep + \beta_3 Age_{36-50} + \beta_4  Age_{51-64} + \beta_5 Age_{65+} + \beta_6 Male \Big)$$

Where coefs are chosen roughly similar to a fitted model to pew that yields a sample size around 500. Namely:
```{r, echo = F}
r33$selection_coefs_kable
```

This yields the following sampling  probabilities

```{r, echo = F}
r33$selection_prob_kable
```

## Outcome Model
Trying to keep things straight forward, I use the identical outcome model with coefficients chosen to roughly match the observed vote choice republican margin. In other words, again we have:
$$p(Vote=D) = \alpha + \beta_1 Indep + \beta_2 Rep + \beta_3 Age_{36-50} + \beta_4  Age_{51-64} + \beta_5 Age_{65+} + \beta_6 Male$$

Coeficients were chose to be realistic and to yield $\hat{y}$'s that lie within a probability range:

```{r, echo = F}
r33$coefs_outcome_kable
```

This yields a population target  in percentage points of:
```{r, echo = F}
cat(paste0(round(r33$target,4)*100, "%"))
```


I then add normally distributed noise to this outcome with mean zero and standard deviation $\sigma = sd(Y)*noise$. 

I run simulations where this noise ratio is $\sqrt(2)$, yielding an $R^2$ of .33, and of $\frac{1}{2}*\sqrt(2)$ yielding an $R^2$ of .66. Finally, I run one last batch of simulations additionally adding noise by defining the outcome as bernoulli draws using the $\hat{y}$'s with $R^2$ of .66. This yields a $R^2$ of 0.017.

```{r, echo = F}
cat(paste0("For R2=",round(r33$R2,3), " the correlation with p(S=1) is ", round(r33$corr,2), "\n"))
cat(paste0("For R2=",round(r66$R2,3), " the correlation with p(S=1) is ", round(r66$corr,2), "\n"))
cat(paste0("For R2=",round(r66_bern$R2,3), " the correlation with p(S=1) is ", 
           round(r66_bern$corr,2), "\n"))
```


# Results


```{r, echo = F}
load(r33_file)

good = which(lapply(sims, function (x) return(class(x))) == "list")

r33_emp_SEs = empirical_SEs(sims = sims)

kable(round(bias, 3), format = "latex", booktabs = T,
      caption = paste0("Bias \\textbf{in Percent} across ", length(good),
                       " sims: All Methods (Target = ", 
                       round(mean(outcome),3)*100, "), $R^2$ on Outcome = ", round(r33$R2, 3)))


kable(round(r33_emp_SEs$emp_SEs[,c(5:ncol(r33_emp_SEs$emp_SEs))]*100,3), 
      format = "latex", booktabs = T, 
      caption = paste("Empirical SE Results \\textbf{in Percent}: Avg SE + Boot SE (sd(estimate)) ", 
                          length(good), "sims; $R^2$ on Outcome = ", round(r33$R2, 3)))


kable(round(SE_coverage[-5, c(5:ncol(SE_coverage))], 3), format = "latex", booktabs = T,
          caption = paste("SE Coverage Results: Kpop", 
                          length(good), "sims; $R^2$ on Outcome = ", round(r33$R2, 3)))

```



```{r, echo=F}
load(r66_file)

good = which(lapply(sims, function (x) return(class(x))) == "list")

r66_emp_SEs = empirical_SEs(sims = sims)

kable(round(bias, 3), format = "latex", booktabs = T,
      caption = paste0("Bias \\textbf{in Percent} across ", length(good),
      " sims: All Methods (Target = ", round(mean(outcome),3)*100, "), $R^2$ on Outcome = ",
      round(r66$R2, 3)))

kable(round(r66_emp_SEs$emp_SEs[,c(5:ncol(r66_emp_SEs$emp_SEs))]*100,3), format = "latex", booktabs = T, 
      caption = paste("Empirical SE Results \\textbf{in Percent}: Avg SE + Boot SE (sd(estimate)) ", 
                          length(good), "sims; $R^2$ on Outcome = ", round(r66$R2, 3)))

kable(round(SE_coverage[-5, c(5:ncol(SE_coverage))], 3), format = "latex", booktabs = T,
          caption = paste("SE Coverage Results: Kpop",
                          length(good), "sims; $R^2$ on Outcome = ", round(r66$R2, 3)))

```


```{r, echo = F}
load(r66_bern_file)

good = which(lapply(sims, function (x) return(class(x))) == "list")

r66_bern_emp_SEs = empirical_SEs(sims = sims)

kable(round(bias, 3), format = "latex", booktabs = T,
      caption = paste0("Bias \\textbf{in Percent} across ", length(good),
      " sims: All Methods (Target = ", round(mean(outcome),3)*100, "), $R^2$ on Outcome = ",
      round(r66_bern$R2, 3)))

kable(round(r66_bern_emp_SEs$emp_SEs[,c(5:ncol(r66_bern_emp_SEs$emp_SEs))]*100,3), 
      format = "latex", booktabs = T, 
      caption = paste("Empirical SE Results \\textbf{in Percent}: Avg SE + Boot SE (sd(estimate)) ", 
                          length(good), "sims; $R^2$ on Outcome = ", round(r66_bern$R2, 3)))

kable(round(SE_coverage[-5, c(5:ncol(SE_coverage))], 3), format = "latex", booktabs = T,
          caption = paste("SE Coverage Results: Kpop",
                          length(good), "sims; $R^2$ on Outcome = ", round(r66_bern$R2, 3)))


```