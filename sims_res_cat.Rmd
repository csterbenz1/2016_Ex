---
title: "sims_cat_res"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
set.seed(9345876)

### Packages
library(MASS)
library(tidyverse)
library(survey)
library(kbal)
library(parallel)
library(knitr)
library(glmnet)
library(caret)
library(xgboost)
POPW = FALSE
```

```{r set_params}
###### SET PARAMS  ###############
set.seed(9345876)

if(detectCores() > 10) {
    path_data= "../Data/"
} else {
    path_data= "/Users/Ciara/Dropbox/kpop/application/data/" 
}

POPW = FALSE
cores_saved = 23
nsims = (detectCores()-cores_saved)*20
nsims
eval_kpop = TRUE
TEST = FALSE # to run with a linear kernel so it's way faster
tolerance = 1e-4
maxit = 500
#both for runtime
increment = 5
min_num_dims = 140
max_num_dims = 500 


eval_sims = FALSE
```




```{r sims dat used, eval = T}
###################### Formulas ################
formula_rake_demos_noeduc <- ~recode_age_bucket + recode_female + recode_race + 
    recode_region + recode_pid_3way

formula_rake_demos_weduc <- ~recode_age_bucket + recode_female + 
    recode_race + recode_region + recode_educ_3way + recode_pid_3way

formula_rake_all_vars <- ~recode_age_bucket + recode_female + 
    recode_race + recode_region + recode_pid_3way + recode_educ +
    recode_income_5way + recode_relig_6way + recode_born + recode_attndch_4way

formula_ps <- ~recode_age_3way + recode_female + recode_race +
    recode_region + recode_educ_wh_3way + recode_pid_3way

formula_ps_reduc <- ~recode_age_3way + recode_female + 
    recode_race + recode_region + recode_pid_3way  +
    recode_income_3way + recode_born + recode_educ_wh_3way

#let's coarsen income and religion and attend church for all:
formula_ps_all <- ~recode_age_3way + recode_female + 
    recode_race + recode_region + recode_pid_3way + recode_educ_3way +
    recode_income_3way + recode_relig_6way + recode_born + recode_attndch_bin


#### (4) Selection model (also rake_demo_truth)
selection_model = as.formula(~recode_female:recode_pid_3way + recode_age:recode_pid_3way + recode_race:recode_region:recode_educ_wh_3way:recode_pid_3way + recode_age + I(recode_age^2))

create_targets <- function (target_design, target_formula) {
    target_mf <- model.frame(target_formula, model.frame(target_design))
    target_mm <- model.matrix(target_formula, target_mf)
    wts <- weights(target_design)
    
    return(colSums(target_mm * wts) / sum(wts))
}

### Post-stratification function
## For now assumes that strata variable is already created and in
## the data set and called "strata"
postStrat <- function(survey, pop_counts, pop_w_col, strata_pass) {
    survey_counts <- survey %>%
        group_by(!!as.symbol(strata_pass)) %>%
        summarize(n = n()) %>%
        ungroup() %>%
        mutate(w_survey = n / sum(n))
    
    pop_counts <- pop_counts %>%
        rename(w_pop = matches(pop_w_col))
    
    post_strat <- pop_counts %>%
        left_join(survey_counts, by = strata_pass) %>%
        filter(!is.na(w_survey)) %>%
        ## Normalizes back to 1 after dropping
        ## empty cells
        mutate(w_pop = w_pop * 1/sum(w_pop),
               w = w_pop / w_survey) %>%
        dplyr::select(!!as.symbol(strata_pass), w)
    
    survey <- survey %>%
        left_join(post_strat)
    
    return(survey)
}



############# Load Data #####################

## Load Pew (no def not vote) THIS KEEPS DNK VOTERS
pew <- readRDS(paste0(path_data, "pew_new.rds"))
#if want to drop no dnk:
# pew <- pew %>%
#     filter(plan1 %in% c("Plan to vote", "Already voted"))
#drop the pew units missing data (on age and)
pew <- pew %>% filter(missing == 0)

### Load Target Data
cces <- readRDS(paste0(path_data, "cces_new.rds"))


### Drop no-response-cases 
cces <- cces %>%
    filter((CC16_401 == "I definitely voted in the General Election.") &
               !is.na(commonweight_vv_post) &
               !is.na(recode_vote_2016)) %>%
    ## renormalize cces weights
    mutate(commonweight_vv_post = commonweight_vv_post/ mean(commonweight_vv_post))


###### adding some interactions and higher order stuff
cces <- cces %>% mutate(
    #36 levels
    recode_educ_pid_race = as.factor(paste(recode_educ_3way,
                                           recode_pid_3way, 
                                           recode_race, sep = ", ")),
    #12 levels
    recode_pid_race = as.factor(paste(recode_pid_3way, 
                                      recode_race, sep = ", ")),
    #9 levels
    recode_educ_pid = as.factor(paste(recode_educ_3way,
                                      recode_pid_3way, sep = ", ")),
    recode_agesq = recode_age*recode_age,
    recode_agecubed = recode_age*recode_age*recode_age,
    #13 levels
    recode_midwest_edu_race = as.factor(
        case_when(recode_region == "Midwest" ~ paste(recode_region,
                                                     recode_race,
                                                     recode_educ_3way, 
                                                     sep = ", "),
                  TRUE ~ "No Split")), 
    #4 levels ( low educated whites in midwest only)
    recode_midwest_wh_edu = factor(case_when(
        (recode_race != "White" | recode_region != "Midwest") ~ "No Split", 
        TRUE ~ as.character(recode_educ_3way)), 
        levels = c("No Split", "No College", "College", "Post-grad")), 
    recode_age_factor = factor(case_when(recode_age <92 ~ as.character(recode_age), 
                                         TRUE ~ "92+"))
)
cces <- cces %>% mutate(recode_attndch_bin = 
                            factor(ifelse(recode_attndch_4way== "Never", "No", "Yes")))

pew <- pew %>% mutate(recode_attndch_bin = 
                          factor(ifelse(recode_attndch_4way== "Never", "No", "Yes")))
pew <- pew %>% mutate(
    #this has 36 levles
    recode_educ_pid_race = as.factor(paste(recode_educ_3way,
                                           recode_pid_3way, 
                                           recode_race, sep = ", ")),
    #12 levels
    recode_pid_race = as.factor(paste(recode_pid_3way, 
                                      recode_race, sep = ", ")),
    #this has 9 levles
    recode_educ_pid = as.factor(paste(recode_educ_3way,
                                      recode_pid_3way, sep = ", ")),
    recode_agesq = recode_age*recode_age,
    recode_agecubed = recode_age*recode_age*recode_age,
    
    #this has 13 levels
    recode_midwest_edu_race = as.factor(
        case_when(recode_region == "Midwest" ~ paste(recode_region,
                                                     recode_race,
                                                     recode_educ_3way, 
                                                     sep = ", "),
                  TRUE ~ "No Split")),
    #this has 4 levels
    recode_midwest_wh_edu = factor(case_when(
        (recode_race != "White" | recode_region != "Midwest") ~ "No Split", 
        TRUE ~ as.character(recode_educ_3way)), 
        levels = c("No Split", "No College", "College", "Post-grad")),
    recode_age_factor = factor(case_when(recode_age <92 ~ as.character(recode_age), 
                                         TRUE ~ "92+")) )


######### Make STRATA variable in CCES and Pew ############
cces <- bind_cols(cces, cces %>% 
                      unite("strata", all.vars(formula_ps), remove = FALSE) %>%
                      unite("strata_reduc", all.vars(formula_ps_reduc), 
                            remove = FALSE) %>%
                      unite("strata_all", all.vars(formula_ps_all)) %>%
                      dplyr::select(strata, strata_reduc, strata_all))

pew <- bind_cols(pew, pew %>% 
                     unite("strata", all.vars(formula_ps), remove = FALSE) %>%
                     unite("strata_reduc", all.vars(formula_ps_reduc), 
                           remove = FALSE) %>%
                     unite("strata_all", all.vars(formula_ps_all)) %>%
                     dplyr::select(strata, strata_reduc, strata_all))

###### reduce size for memory:
pew <- pew[,c(210:ncol(pew))]
cces <- cces[, c(3,564:ncol(cces))]
```


```{r sims_code_prep, eval = T}
##################### LASSO: Selection #############################
# Stack data with S = 1 indicating Pew
stack_data <- data.frame(bind_rows(pew, cces), S = c(rep(1, nrow(pew)), rep(0, nrow(cces))))
mod <- model.matrix(selection_model, data = stack_data)
## Remove columns where Pew missing strata
ncol(mod)
mod <- mod[, apply(mod[stack_data$S == 1, ], 2, sum) != 0]
## Remove columns where CCES missing Strata
mod <- mod[, apply(mod[stack_data$S == 0, ], 2, sum) != 0]
ncol(mod)

#lambda from 10 fold default CV
#had to remove the intercept in mod and have glmnet add it cause other wise even with intercept false it was adding two intercepts
lasso_lambda <- cv.glmnet(x= mod[,-1], 
                          y = as.matrix(stack_data$S),
                          alpha = 1,
                          family = "binomial",
                          intercept = TRUE)

lasso_include <- glmnet(x= mod[,-1], 
                        y = as.matrix(stack_data$S),
                        alpha = 1,
                        lambda = lasso_lambda$lambda.min,
                        weights = if(POPW){ c(rep(1, nrow(pew)),
                                             cces$commonweight_vv_post)} else {NULL},
                        family = "binomial",
                        intercept = TRUE)

lasso_include_coefs <- coef(lasso_include) 
#drops 28 for min; drops 69 dec 2020 (prev 70 for 1se
sum(lasso_include_coefs == 0)
#march 2021 drops 8 for min, 82!! for 1se 
#weird bc i dont know what would have changed here
#probability of being in pew for cces 
lasso_pinclude = predict(lasso_include,
                         s= lasso_lambda$lambda.min,
                         type = "response",
                         newx = mod[stack_data$S == 0,-1])

########### res
p_include <- lasso_pinclude
summary(p_include)


## Code whether vote choice is for Republican candidate
cces<- cces %>% mutate(recode_vote_2016_binary = as.numeric(recode_vote_2016 == "Republican"))

## Drop the "Other" responses so we can model two-way vote share 
Y_keep <- stack_data$recode_vote_2016 != "Other" & stack_data$S == 0

###################### LASSO ####################
#lambda from 10 fold default CV
lasso_lambda_2 <- cv.glmnet(x= mod[Y_keep,-1], 
                            y = cces$recode_vote_2016_binary[cces$recode_vote_2016 != "Other"],
                            alpha = 1,
                            family = "binomial",
                            weights = if(POPW){cces$commonweight_vv_post[cces$recode_vote_2016 != "Other"]} else {NULL},
                            intercept = TRUE)

lasso_vote <- glmnet(x= mod[Y_keep, -1], 
                     y = cces$recode_vote_2016_binary[cces$recode_vote_2016 != "Other"],
                     alpha = 1,
                     lambda = lasso_lambda_2$lambda.min,
                     family = "binomial",
                     weights = if(POPW){cces$commonweight_vv_post[cces$recode_vote_2016 != "Other"]} else {NULL},
                     intercept = TRUE)

lasso_pvote = predict(lasso_vote,
                      s= lasso_lambda_2$lambda.min,
                      type = "response",
                      newx = mod[stack_data$S==0,-1])


lasso_vote_coefs <- coef(lasso_vote)
#jan 2021: lambda.min drops 10/83
#march 2021: min 10/83, 1se drops 37
sum(lasso_vote_coefs ==0)

#########
# ## Add simulated results to CCES data
cces <- cces %>%
    mutate(recode_vote_2016_sim = lasso_pvote)

p_vote <- lasso_pvote

summary(p_vote)
#jan 2021: .169
cor(p_vote, p_include)

#################### Targets ###################
if(POPW) {
    cces_svy <- svydesign(ids = ~1, weights = ~commonweight_vv_post, data = cces)
} else {
    cces_svy <- svydesign(ids = ~1, data = cces)
}
targets_rake_demos_noeduc <- create_targets(cces_svy,
                                            formula_rake_demos_noeduc)
targets_rake_demos_weduc <- create_targets(cces_svy, formula_rake_demos_weduc)
targets_rake_all_vars <- create_targets(cces_svy, 
                                        formula_rake_all_vars)
targets_demo_truth <- create_targets(cces_svy, selection_model)
margin_sim = (0.5 - svymean(~recode_vote_2016_sim, cces_svy)[1]) * 2 * 100

## Make table of Population Counts for post-stratification for manual ps function
cces_counts <- cces %>%
    group_by(strata) %>%
    summarize(n = if(!POPW) {n()} else {sum(commonweight_vv_post, na.rm = TRUE)}) %>%
    ungroup() %>%
    mutate(w = n / sum(n, na.rm = TRUE))

cces_reduc_counts <- cces %>%
    group_by(strata_reduc) %>%
    summarize(n = if(!POPW) {n()} else {sum(commonweight_vv_post, na.rm = TRUE)}) %>%
    ungroup() %>%
    mutate(w_reduc = n / sum(n, na.rm = TRUE)) 

cces_all_counts <- cces %>% 
    group_by(strata_all) %>% 
    summarize(n = if(!POPW) {n()} else {sum(commonweight_vv_post, na.rm = TRUE)}) %>%
    ungroup() %>%
    mutate(w_all = n / sum(n, na.rm = TRUE)) 

#alt can build targets and used canned (same res)
# targets_ps <- svytable(formula = ~strata,
#                        design = cces_svy)
# targets_ps_reduc <- svytable(formula = ~strata_reduc,
#                              design = cces_svy)
# targets_ps_all <- svytable(formula = ~strata_all,
#                           design = cces_svy)
```


```{r run_sims, eval = eval_sims}
########################### RUN SIMS ##################################
#save mem
rm(pew, lasso_pinclude, lasso_include, lasso_pvote, lasso_vote, lasso_lambda, lasso_lambda_2,
stack_data, mod)
# workspace.size <- function() {
#   ws <- sum(sapply(ls(envir=globalenv()), function(x)object.size(get(x))))
#   class(ws) <- "object_size"
#   ws
# }
# #in megabytes: 
# workspace.size()/1000000

margins_formula <- ~recode_vote_2016 + recode_vote_2016_sim + 
    recode_pid_3way + 
    recode_female + recode_race +recode_region + recode_educ + recode_relig_6way + 
    recode_born + recode_attndch_4way + recode_income_5way +
    recode_age_bucket + recode_age + recode_agesq + recode_agecubed + recode_age_factor + 
    recode_race_educ_reg + recode_educ_wh_3way + 
    recode_educ_pid_race +
    recode_pid_race + 
    recode_educ_pid +
    recode_midwest_edu_race +
    recode_midwest_wh_edu


nsims
tic()
system.time({
    sims <- mclapply(1:nsims, function(nsim) {
        seed <- round(runif(1)*100000)
        set.seed(seed)
        cat(paste("=====================  SIM:",nsim, "SEED" , seed,
                  "===================== \n"))
        sample <- rbinom(nrow(cces), 1, p_include)
        
        survey_sim <- cces[sample == 1, ]
        survey_design <- svydesign(ids = ~1, data = survey_sim)
        
        ############################################
        ## Unweighted estimate
        ############################################
        
        unweighted <- est_mean("recode_vote_2016_sim", survey_design)
        ############################################
        ## Sample size
        ############################################
        n <- sum(sample)
        
        ############################################
        ## Raking on demographics (no education)
        ############################################
        rake_demos_noeduc_svyd <- calibrate(design = survey_design,
                                            formula = formula_rake_demos_noeduc,
                                            population = targets_rake_demos_noeduc,
                                            calfun = "raking")
        
        rake_demos_noeduc <- est_mean("recode_vote_2016_sim", rake_demos_noeduc_svyd)
        ############################################
        #### Raking on demographics (with education)
        ############################################
        rake_demos_weduc_svyd <- calibrate(design = survey_design,
                                           formula = formula_rake_demos_weduc,
                                           population = targets_rake_demos_weduc,
                                           calfun = "raking")
        
        rake_demos_weduc <- est_mean("recode_vote_2016_sim", rake_demos_weduc_svyd)
        
        
        ############################################
        #### Raking on everything
        ############################################
        rake_all_svyd <- calibrate(design = survey_design,
                                           formula = formula_rake_all_vars,
                                           population = targets_rake_all_vars,
                                           calfun = "raking")
        
        rake_all <- est_mean("recode_vote_2016_sim", rake_all_svyd)
        
        
        ############################################
        ## Post-stratification: Old Formula
        ############################################
        post_stratification_svyd = svydesign(~1, data = postStrat(survey_sim, 
                                                                  cces_counts, "w", 
                                                                  strata_pass = "strata"),
                                             weights = ~w)
        
        post_stratification <- est_mean("recode_vote_2016_sim", post_stratification_svyd)
        
        ############################################
        ## Post-stratification: Reduced
        ############################################
        post_strat_reduc_svyd = svydesign(~1, data = postStrat(survey_sim, 
                                                                  cces_reduc_counts, "w_reduc", 
                                                               strata_pass = "strata_reduc"),
                                             weights = ~w)
        
        post_strat_reduc <- est_mean("recode_vote_2016_sim", post_strat_reduc_svyd)
        
        ############################################
        ## Post-stratification: All
        ############################################
        post_strat_all_svyd = svydesign(~1, data = postStrat(survey_sim, 
                                                                  cces_all_counts, "w_all", 
                                                             strata_pass = "strata_all"),
                                             weights = ~w)
        
        post_strat_all <- est_mean("recode_vote_2016_sim", post_strat_all_svyd)
        
        ############################################
        #### Raking on true model
        ############################################
        rake_truth_svyd <- try(calibrate(design = survey_design,
                                         formula = selection_model,
                                         population = targets_demo_truth,
                                         calfun = "raking",
                                         epsilon = 0.005))
        
        if ("try-error"%in%class(rake_truth_svyd)[1]){
            rake_truth <- NA
            names(rake_truth) <- "recode_vote_2016_sim"
        } else {
            rake_truth <- est_mean("recode_vote_2016_sim", rake_truth_svyd)
        }
        
        ############################################
        ## Kpop: Categorical Data + b = argmax V(K)
        ############################################
        
        ## Select the covariates for use in Kbal: updated cat data no cont age
        #one-hot coded for cat kernel
        kbal_data <- bind_rows(survey_sim %>% dplyr::select(recode_age_bucket,
                                                     recode_female,
                                                     recode_race,
                                                     recode_region,
                                                     recode_pid_3way,
                                                     recode_educ,
                                                     
                                                     recode_income_5way,
                                                     recode_relig_6way,
                                                     recode_born,
                                                     recode_attndch_4way),
                               cces %>% dplyr::select(recode_age_bucket,
                                                      recode_female,
                                                      recode_race,
                                                      recode_region,
                                                      recode_pid_3way,
                                                      recode_educ,
                                                      
                                                      recode_income_5way,
                                                      recode_relig_6way,
                                                      recode_born,
                                                      recode_attndch_4way)) 
        kbal_data <- data.frame(lapply(kbal_data, as.factor))
        kbal_data <- model.matrix(~ ., kbal_data,
                                  contrasts.arg = lapply(kbal_data, 
                                                         contrasts, contrasts=FALSE))
        kbal_data <- kbal_data[, -1]
        kbal_data_sampled <- c(rep(1, nrow(survey_sim)), rep(0, nrow(cces)))
        
        K <- makeK(kbal_data, b=2, useasbases = kbal_data_sampled,
                   linkernel = FALSE, scale = FALSE)
        raw_counts <- -log(K)
        
        #### now get alt b's 
        #run optim: much faster than table
        n_d <- data.frame(diff = c(raw_counts)) %>% group_by(diff) %>% summarise(n())
        n_d <- as.vector(n_d[,2] %>% pull())
        res = optimize(var_K, n_d = n_d,
                       interval=c(0,2000), maximum=TRUE)
        b_maxvar <- res$maximum
        
        #bmean:
        b_mean <- mean(as.vector(raw_counts))
        
        ##### Demos Constraint
        rake_demos_constraint <- bind_rows(survey_sim %>% dplyr::select(recode_age_bucket,
                                                                 recode_female,
                                                                 recode_race,
                                                                 recode_region,
                                                                 recode_pid_3way),
                                           cces %>% dplyr::select(recode_age_bucket,
                                                                            recode_female,
                                                                            recode_race,
                                                                            recode_region,
                                                                            recode_pid_3way))%>%
            model.matrix(as.formula("~."), .)
        
        rake_demos_constraint <- rake_demos_constraint[,-1]
        rake_demos_constraint <- scale(rake_demos_constraint)
        
        
        rake_demos_wedu_constraint <- bind_rows(survey_sim %>% dplyr::select(recode_age_bucket,
                                                                      recode_female,
                                                                      recode_race,
                                                                      recode_region,
                                                                      recode_pid_3way,
                                                                      recode_educ),
                                                cces %>% dplyr::select(recode_age_bucket,
                                                                                 recode_female,
                                                                                 recode_race,
                                                                                 recode_region,
                                                                                 recode_pid_3way,
                                                                                 recode_educ))%>%
            model.matrix(as.formula("~."), .)
        
        rake_demos_wedu_constraint <- rake_demos_wedu_constraint[,-1]
        rake_demos_wedu_constraint <- scale(rake_demos_wedu_constraint)
        
        
        rake_all_constraint <- bind_rows(survey_sim %>% dplyr::select(recode_age_bucket,
                                                               recode_female,
                                                               recode_race,
                                                               recode_region,
                                                               recode_pid_3way,
                                                               recode_educ,
                                                               
                                                               recode_income_5way,
                                                               recode_relig_6way,
                                                               recode_born,
                                                               recode_attndch_4way),
                                         cces %>% dplyr::select(recode_age_bucket,
                                                                          recode_female,
                                                                          recode_race,
                                                                          recode_region,
                                                                          recode_pid_3way,
                                                                          recode_educ,
                                                                          recode_income_5way,
                                                                          recode_relig_6way,
                                                                          recode_born,
                                                                          recode_attndch_4way)) %>%
            model.matrix(as.formula("~."), .)
        
        rake_all_constraint <- rake_all_constraint[,-1]
        rake_all_constraint <- scale(rake_all_constraint)
    
        rm(K, res, raw_counts)
        #option to check more b values
        #b <- c(b_mean, b_maxvar*2, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048)
        #b <- c(b_mean, b_maxvar*2)
        b <- c(b_maxvar*2)
        if(eval_kpop) {
            kpop <- lapply(1:length(b), function(i) {
                
                #cat("===================== Running Kbal ==================\n")
                
                
                #### DEFAULT ######
                cat(paste("b:", b[i], "nsim:", nsim, "DEFAULT", "\n"))
                kbal_est <- kbal(allx=kbal_data,
                             sampled = kbal_data_sampled,
                             b = b[i],
                             scale_data = FALSE,
                             drop_multicollin = FALSE,
                             incrementby = increment,
                             meanfirst = FALSE,
                             ebal.tol = tolerance,
                             ebal.maxit = maxit,
                             minnumdims = min_num_dims,
                             maxnumdims = max_num_dims,
                             linkernel = if(TEST){TRUE} else{ FALSE},
                             sampledinpop = FALSE,
                             fullSVD = TRUE)
                
                kpop_svyd <- svydesign(~1, data = survey_sim,
                                       weights = kbal_est$w[kbal_data_sampled ==1])
                
                kpop <- est_mean("recode_vote_2016_sim", kpop_svyd)
                
                #save memory by saving only the svd to re use
                svdK = kbal_est$svdK 
                numdims = kbal_est$numdims
                biasbound_r = kbal_est$biasbound.orig/kbal_est$biasbound.opt
                biasbound = kbal_est$biasbound.opt
                
                #CONVERGED
                dist_record = data.frame(t(kbal_est$dist.record))
                min_converged = dist_record[which.min(dist_record[dist_record$Ebal.Convergence ==1,"BiasBound"]), "Dims"]
                
                rm(kbal_est)
                
                #### CONVG ####
                cat(paste("b:", b[i], "nsim:", nsim, "CONV", "\n"))
                if(is.null(min_converged) | length(min_converged) ==0) {
                    kpop_svyd_conv <- "dn converge"
                    kpop_conv <- "dn converge"
                    
                    numdims_conv = "dn converge"
                    biasbound_r_conv = "dn converge"
                    biasbound_conv = "dn converge"
                    
                } else {
                    kbal_est_conv <- kbal(allx=kbal_data,
                                      K.svd = svdK,
                                      sampled = kbal_data_sampled,
                                      numdims = min_converged,
                                      ebal.tol = tolerance,
                                      ebal.maxit = maxit,
                                      minnumdims = min_num_dims,
                                      maxnumdims = max_num_dims,
                                      scale_data = FALSE,
                                      drop_multicollin = FALSE,
                                      incrementby = increment,
                                      meanfirst = FALSE,
                                      sampledinpop = FALSE,
                                      ebal.convergence = TRUE)
                    kpop_svyd_conv <- svydesign(~1, data = survey_sim,
                                                weights = kbal_est_conv$w[kbal_data_sampled ==1])
                    kpop_conv <- est_mean("recode_vote_2016_sim", kpop_svyd_conv)
                    
                    numdims_conv = kbal_est_conv$numdims
                    biasbound_r_conv = kbal_est_conv$biasbound.orig/kbal_est_conv$biasbound.opt
                    biasbound_conv = kbal_est_conv$biasbound.opt
                    rm(kbal_est_conv)
                    
                }
                
                
               
                
                ####### MF #######
                cat(paste("b:", b[i], "nsim:", nsim, "MEANFIRST", "\n"))
                kbal_mf_est <- kbal(K.svd = svdK,
                                    allx=kbal_data,
                                    sampled = kbal_data_sampled,
                                    ebal.tol = tolerance,
                                    ebal.maxit = maxit,
                                    minnumdims = min_num_dims,
                                    maxnumdims = max_num_dims,
                                    scale_data = FALSE,
                                    drop_multicollin = FALSE,
                                    incrementby = increment,
                                    meanfirst = TRUE,
                                    sampledinpop = FALSE)
                
                kpop_mf_svyd <- svydesign(~1, data = survey_sim, 
                                          weights = kbal_mf_est$w[kbal_data_sampled ==1])
                
                kpop_mf <- est_mean("recode_vote_2016_sim", kpop_mf_svyd)
                
                mfnumdims = kbal_mf_est$numdims
                if(is.null(mfnumdims)) {mfnumdims = c("dn_converge") }
                mf_appended_dims = kbal_mf_est$meanfirst.dims
                if(is.null(mf_appended_dims)) {mf_appended_dims = c("dn_converge")}
                biasbound_r_mf = kbal_mf_est$biasbound.orig/kbal_mf_est$biasbound.opt
                biasbound_mf = kbal_mf_est$biasbound.opt
                
                rm(kbal_mf_est)
                
                
                #########demos constraint method:
                cat(paste("b:", b[i], "nsim:", nsim, "CONSTR", "\n"))
                kbal_demos_est <- kbal(K.svd = svdK,
                                        allx=kbal_data,
                                        sampled = kbal_data_sampled,
                                        ebal.tol = tolerance,
                                        ebal.maxit = maxit,
                                       minnumdims = min_num_dims,
                                       maxnumdims = max_num_dims,
                                        scale_data = FALSE,
                                        drop_multicollin = FALSE,
                                        incrementby = increment,
                                        #scaling these
                                        constraint = rake_demos_constraint,
                                        meanfirst = FALSE,
                                        sampledinpop = FALSE)
                kpop_demos_svyd <- svydesign(~1, data = survey_sim, 
                                          weights = kbal_demos_est$w[kbal_data_sampled ==1])
                
                kpop_demos <- est_mean("recode_vote_2016_sim", kpop_demos_svyd)
                
                numdims_demos = kbal_demos_est$numdims
                if(is.null(numdims_demos)) {numdims_demos = c("dn_converge") }
                biasbound_r_demos = kbal_demos_est$biasbound.orig/kbal_demos_est$biasbound.opt
                biasbound_demos = kbal_demos_est$biasbound.opt
                
                rm(kbal_demos_est)
                
                
                #########demos + educ constraint method:
                cat(paste("b:", b[i], "nsim:", nsim, "CONSTR", "\n"))
                kbal_demos_wedu_est <- kbal(K.svd = svdK,
                                            allx=kbal_data,
                                            sampled = kbal_data_sampled,
                                            ebal.tol = tolerance,
                                            ebal.maxit = maxit,
                                            minnumdims = min_num_dims,
                                            maxnumdims = max_num_dims,
                                            scale_data = FALSE,
                                            drop_multicollin = FALSE,
                                            incrementby = increment,
                                            #scaling these
                                            constraint = rake_demos_wedu_constraint,
                                            meanfirst = FALSE,
                                            sampledinpop = FALSE)
                kpop_demos_wedu_svyd <- svydesign(~1, data = survey_sim, 
                                              weights = kbal_demos_wedu_est$w[kbal_data_sampled ==1])
                
                kpop_demos_wedu <- est_mean("recode_vote_2016_sim", kpop_demos_wedu_svyd)
                
                numdims_demos_wedu = kbal_demos_wedu_est$numdims
                if(is.null(numdims_demos_wedu)) {numdims_demos_wedu = c("dn_converge") }
                biasbound_r_demos_wedu = kbal_demos_wedu_est$biasbound.orig/kbal_demos_wedu_est$biasbound.opt
                biasbound_demos_wedu = kbal_demos_wedu_est$biasbound.opt
                
                rm(kbal_demos_wedu_est)
                
                
                #########all constraint method:
                cat(paste("b:", b[i], "nsim:", nsim, "CONSTR", "\n"))
                kbal_all_est <- kbal(K.svd = svdK,
                                            allx=kbal_data,
                                            sampled = kbal_data_sampled,
                                            ebal.tol = tolerance,
                                            ebal.maxit = maxit,
                                     minnumdims = min_num_dims,
                                     maxnumdims = max_num_dims,
                                            scale_data = FALSE,
                                            drop_multicollin = FALSE,
                                            incrementby = increment,
                                            #scaling these
                                            constraint = rake_all_constraint,
                                            meanfirst = FALSE,
                                            sampledinpop = FALSE)
                kpop_all_svyd <- svydesign(~1, data = survey_sim, 
                                              weights = kbal_all_est$w[kbal_data_sampled ==1])
                
                kpop_all <- est_mean("recode_vote_2016_sim", kpop_all_svyd)
                
                numdims_all = kbal_all_est$numdims
                if(is.null(numdims_all)) {numdims_all = c("dn_converge") }
                biasbound_r_all = kbal_all_est$biasbound.orig/kbal_all_est$biasbound.opt
                biasbound_all = kbal_all_est$biasbound.opt
                
                rm(kbal_all_est)
                
                rm(svdK)
                
                ##### return
                out = list()
                out$sims = data.frame(seed,
                                        b[i],
                                      kpop,
                                      kpop_mf,
                                      kpop_conv,
                                      kpop_demos,
                                      kpop_demos_wedu,
                                      kpop_all,
                                      bb = biasbound,
                                      bbr = biasbound_r,
                                      bb_conv = biasbound_conv,
                                      bbr_conv = biasbound_r_conv,
                                      bb_mf = biasbound_mf,
                                      bbr_mf = biasbound_r_mf,
                                      bb_demos = biasbound_demos,
                                      bbr_demos = biasbound_r_demos,
                                      bb_demos_wedu = biasbound_demos_wedu,
                                      bbr_demos_wedu = biasbound_r_demos_wedu,
                                      bb_all = biasbound_all,
                                      bbr_all = biasbound_r_all,
                                      numdims,
                                      numdims_conv,
                                      mfnumdims, 
                                      mf_appended_dims, 
                                      numdims_demos,
                                      numdims_demos_wedu,
                                      numdims_all)
                #weights
                out$weights = list(seed, 
                                   b[i],
                                   kpop_w = weights(kpop_svyd),
                                   kpop_w_conv = weights(kpop_svyd_conv),
                                   kpop_mf_w = weights(kpop_mf_svyd), 
                                   kpop_demos_w = weights(kpop_demos_svyd),
                                   kpop_demos_wedu_w = weights(kpop_demos_wedu_svyd),
                                   kpop_all_w = weights(kpop_all_svyd))
                
                ######## Kpop Margins ########
                
                out$km <- round(cbind(seed, 
                                      b = b[i]/100,
                                      kpop = svymean(margins_formula, kpop_svyd),
                                      kpop_conv = svymean(margins_formula, kpop_svyd_conv),
                                      kpop_mf = svymean(margins_formula, kpop_mf_svyd),
                                      kpop_demos = svymean(margins_formula, kpop_demos_svyd),
                                      kpop_demos_wedu = svymean(margins_formula, kpop_demos_wedu_svyd),
                                      kpop_all = svymean(margins_formula, kpop_all_svyd)) * 100,
                                4)
                
                rm(kpop_svyd, kpop_mf_svyd, kpop_svyd_conv, kpop_demos_svyd,
                   kpop_demos_wedu_svyd, kpop_all_svyd)
                
                return(out)
            })
            
        } else {
            kpop <- NA
            kpop_mf<- NA
            kpop_conv<- NA
            kpop_demos <- NA
            kpop_demos_wedu <- NA
            kpop_all <- NA
            
            numdims = NA
            mfnumdims = NA
            mf_appended_dims = NA
            numdims_conv = NA
            numdims_demos = NA
            numdims_demos_wedu = NA
            numdims_all = NA
            biasbound_r = NA
            biasbound = NA
            bb_conv = NA
            bbr_conv = NA
            bb_mf = NA
            bbr_mf = NA
            bb_demos = NA
            bbr_demos = NA
            bb_demos_wedu = NA
            bbr_demos_wedu = NA
            bb_all = NA
            bbr_all = NA
            
        }
        
        ############################################ OUTPUT
        out = list()
        if(eval_kpop) {
            out$sims = cbind(nsim,
                             seed,
                             n,
                             unweighted,
                             rake_demos_noeduc,
                             rake_demos_weduc,
                             rake_all,
                             post_stratification,
                             post_strat_reduc,
                             post_strat_all,
                             rake_truth,
                             lapply(kpop, `[[`,1) %>% bind_rows())
            
            
            margin <- round(cbind(sample = svymean(margins_formula, survey_design),
                                  cces =  svymean(margins_formula, cces_svy),
                                  rake_demos_noeduc = svymean(margins_formula,
                                                              rake_demos_noeduc_svyd),
                                  rake_demos_weduc = svymean(margins_formula,
                                                             rake_demos_weduc_svyd),
                                  rake_all = svymean(margins_formula,
                                                             rake_all_svyd),
                                  post_stratification = svymean(margins_formula,
                                                                post_stratification_svyd),
                                  post_strat_reduc = svymean(margins_formula,
                                                                post_strat_reduc_svyd),
                                  post_strat_all = svymean(margins_formula,
                                                                post_strat_all_svyd),
                                  rake_truth = svymean(margins_formula, rake_truth_svyd)) * 100, 5)
            
            #these are just means so let's not multiply by 100
            margin["recode_age",] <- margin["recode_age",]/100 
            margin["recode_agesq",] <- margin["recode_agesq",]/100
            margin["recode_agecubed",] <- margin["recode_agecubed",]/100
            
            
            margin = cbind(margin,
                           as.data.frame(sapply(kpop, `[`, 3)))
            
            margin <- margin[,grepl("km.kpop", colnames(margin))|
                                 !grepl("km.", colnames(margin)) ]
            
            colnames(margin)[grepl("km.kpop", colnames(margin))] <- unlist(lapply(b, function(x) c(paste0("kpop_b", round(x,3)),
                                           paste0("kpop_cvg_b", round(x,3)), 
                                           paste0("kpop_mf_b", round(x,3)), 
                                           paste0("kpop_demos_b", round(x,3)),
                                           paste0("kpop_demos_wedu_b", round(x,3)) ,
                                           paste0("kpop_all_b", round(x,3)) ) ))
        } else {
            margin <- round(cbind(sample = svymean(margins_formula, survey_design),
                                  cces =  svymean(margins_formula, cces_svy),
                                  rake_demos_noeduc = svymean(margins_formula,
                                                              rake_demos_noeduc_svyd),
                                  rake_demos_weduc = svymean(margins_formula,
                                                             rake_demos_weduc_svyd),
                                  rake_all = svymean(margins_formula,
                                                     rake_all_svyd),
                                  post_stratification = svymean(margins_formula,
                                                                post_stratification_svyd),
                                  post_strat_reduc = svymean(margins_formula,
                                                             post_strat_reduc_svyd),
                                  post_strat_all = svymean(margins_formula,
                                                           post_strat_all_svyd),
                                  rake_truth = svymean(margins_formula, rake_truth_svyd)) * 100, 5)
            
            #these are just means so let's not multiply by 100
            margin["recode_age",] <- margin["recode_age",]/100 
            margin["recode_agesq",] <- margin["recode_agesq",]/100
            margin["recode_agecubed",] <- margin["recode_agecubed",]/100
            
            out$sims = cbind(nsim, n,
                             unweighted,
                             rake_demos_noeduc,
                             rake_demos_weduc,
                             rake_all,
                             post_stratification,
                             post_strat_reduc,
                             post_strat_all,
                             rake_truth)
        }
        
        out$margins = margin
        
        return(out)
        
    }, mc.cores = detectCores() - cores_saved) 
})
toc()

good = which(lapply(sims, function (x) return(class(x))) == "list")
save(sims,tolerance, maxit, increment, min_num_dims,
     file = paste0("./cat_sims_w",POPW, "_m",maxit, "_t",tolerance, "_inc",
                         increment, "mindims", min_num_dims,
                         Sys.Date(),
                         # str_sub(gsub("[[:space:]|[:punct:]]", "_",
                         #              gsub("[:alpha:]", "",
                         #                   Sys.time())),
                         #         start = 1, end = -3),
                         "_nsims", length(good),
                         ".RData"))


```




## Analyze Results

```{r cleaning_sims}
load("./cat_sims_wFALSE_m500_t1e-04_inc5mindims1402021-04-07_nsims500.RData")
good = which(lapply(sims, function (x) return(class(x))) == "list")
length(good)
bad = which(!(c(1:500) %in% good))
#plot[bad]

plot <- lapply(sims, `[[`, 1)
#some of them failed it looks like 
plot <- plot[good] %>% bind_rows()

unlist(lapply(plot, function (x) return(class(x$mfnumdims))) )
bad = which(unlist(lapply(plot, function (x) return(class(x$mfnumdims))) )  == "character")
bad
#looks like ony 182 did not work and only for mf interesting
#turn it into an NA so we can bind rows and carry on
plot[[bad]]$mfnumdims <- NA
plot <- plot[good] %>% bind_rows()
nrow(plot)

#look at numdims dist
apply(plot[,c(32:38)],2, min )
apply(plot[,c(32:38)],2, max )
apply(plot[,c(32:38)],2, sd )

margins <- lapply(sims, `[`, 2)
margins = margins[good]

```

#### Variance of B
```{r LA_b, echo = FALSE}
summary(plot$b.i.)
var(plot$b.i.)

```

### Margins
```{r summarize_margins, echo = FALSE}
test <- as.data.frame(margins) 

#other methods margins
#cols are nsim results, rows are each individual level of each variable
#to summarize perfromance across simulations we can take an average of these
#might also want to take the sd to get some sense of how much variance we get
margins_base <- data.frame(
  sample = test[,grepl("margins.sample", colnames(test))] %>% rowMeans(),
  cces = test[,grepl("margins.cces", colnames(test))] %>% rowMeans(),
  rake_demos_noeduc = test[,grepl("margins.rake_demos_noeduc",
                                  colnames(test))] %>% rowMeans(),
  rake_demos_weduc = test[,grepl("margins.rake_demos_weduc",
                                 colnames(test))] %>% rowMeans(),
  rake_all = test[,grepl("margins.rake_all",
                                 colnames(test))] %>% rowMeans(),
  post_stratification = test[,grepl("margins.post_stratification",
                                    colnames(test))] %>% rowMeans(),
  post_strat_reduc = test[,grepl("margins.post_strat_reduc",
                                    colnames(test))] %>% rowMeans(),
  post_strat_all = test[,grepl("margins.post_strat_all",
                                    colnames(test))] %>% rowMeans(),
  rake_truth = test[,grepl("margins.rake_truth", colnames(test))] %>% rowMeans())

rownames(margins_base) <- sapply(rownames(test), function(x) { 
  if(grepl("recode", x)) {substr(x, 8,nchar(x))} else{x} } )


#if you want to do multiple b's see old files
#we're going to combine all the slightly different b's together here bc
#they are all chosen by our b selection rule of maxvar K
margins_avg <- data.frame(
              kpop = test[,grepl("margins.kpop_b", colnames(test))] %>% rowMeans(), 
              kpop_conv = test[,grepl("margins.kpop_cvg", colnames(test))] %>% rowMeans(), 
              kpop_mf = test[,grepl("margins.kpop_mf", colnames(test))] %>% rowMeans(),
              kpop_demos = test[,grepl("margins.kpop_demos", colnames(test))] %>% rowMeans(),
              kpop_demos_wedu = test[,grepl("margins.kpop_demos_wedu", colnames(test))] %>%
              rowMeans(),
              kpop_all = test[,grepl("margins.kpop_all", colnames(test))] %>% rowMeans()
                  )
#a slight oversight on my part, all margins were *100 to get percents, but age, age^2 and age^3 alone were not for the other methods, they remain *100 in the kpop results however
#so we're off by 3 orders of magnitude for the kpop methods, for things to be comparable we need to go fix this
#these variables dont really make sense to %by 100 bc they're just a straight mean, not likea % among mutually exclusive categories so I will divide the kpop results as well,

margins_avg["recode_age",] <- margins_avg["recode_age",]/100 
margins_avg["recode_agesq",] <- margins_avg["recode_agesq",]/100
margins_avg["recode_agecubed",] <- margins_avg["recode_agecubed",]/100

rownames(margins_avg) <- sapply(rownames(test), function(x) { 
if(grepl("recode", x)) {substr(x, 8,nchar(x))} else{x} } )


#merge with the non kpop methods if you like:
margins_total <- cbind(margins_base, margins_avg)


#this includes the one failed MF iteration w whatever margins it returns (should be balance on the constraints)
#we don't care to much bc not using MF anymroe
margins_diff <- margins_total %>% mutate(
    sample = cces - sample,
    kpop = cces - kpop,
    kpop_conv = cces - kpop_conv, 
    kpop_mf = cces - kpop_mf,
    kpop_demos = cces - kpop_demos,
    kpop_demos_wedu = cces - kpop_demos_wedu,
    kpop_all = cces - kpop_all,
    rake_demos_noeduc = cces - rake_demos_noeduc,
    rake_demos_weduc = cces - rake_demos_weduc,
    rake_all = cces - rake_all,
    post_stratification = cces - post_stratification,
    post_strat_reduc = cces - post_strat_reduc,
    post_strat_all = cces - post_strat_all,
    rake_truth = cces - rake_truth)
rownames(margins_diff) <- rownames(margins_total)

#combining the factored age bins into a weighted L1 distance
#weighting the difference by the proportion in that bin in cces
#then we throw in n (number of bins) so that when i take the mean later we get the correct normalization
margins_diff[(grep("age_factor", rownames(margins_diff))), ] <-
      (margins_diff[(grep("age_factor", 
                          rownames(margins_diff))),
                    ])* (margins_total[grep("age_factor", rownames(margins_total)), "cces"]/100)*length(levels(cces$recode_age_factor))


wmabserr <- margins_diff %>% 
    mutate(var = sapply(rownames(margins_diff), 
                        function(y) {
                            substr(y, 1, 
                                   sapply(rownames(margins_diff), 
                                          function(x) {
                                              if(grepl("income",x)) {
                                                  11 #income_5way
                                             #this is so ridiculous WHY (sunk cost ugh)
                                                #keeping all of the outcomes and age margins
                                                #that are not buckets or factored
                                              } else if(grepl("mod", x) | grepl("sim", x) |
                                                        (grepl("age",x) & 
                                                         !grepl("bucket",x) &
                                                         !grepl("factor",x)) ){
                                                  nchar(x) 
                                                  #THIS IS SO STUPID
                                              } else if(grepl("factor",x)) {
                                                  10 #age_factor
                                              } else {
                                               (gregexpr("[A-Z]|[1-9][1-9] |[1-9][1-9]\\+|[1-9]\\-", x)[[1]][1]-1)
                                              }
                                          })[y])
                        })) %>% 
        group_by(var)  %>% 
    summarize(sample = mean(abs(sample)), 
              kpop = mean(abs(kpop)),
              #kpop_conv = mean(abs(kpop_conv)),
              #kpop_mf = mean(abs(kpop_mf)),
              kpop_demos = mean(abs(kpop_demos)),
              rake_demos_noeduc = mean(abs(rake_demos_noeduc)),
              kpop_demos_wedu = mean(abs(kpop_demos_wedu)),
              rake_demos_weduc = mean(abs(rake_demos_weduc)), 
              kpop_all = mean(abs(kpop_all)),
              rake_all = mean(abs(rake_all)), 
              #post_stratification =mean(abs(post_stratification)),
              post_strat_reduc =mean(abs(post_strat_reduc)),
              #post_strat_all =mean(abs(post_strat_all)),
              rake_truth = mean(abs(rake_truth)))

wmabserr$var[wmabserr$var == "educ"]<- "educ_6way"

#drop some of the unnecc margins
wmabserr_nooutcomes <- wmabserr %>%
        filter(!(var %in% c("agecubed") |grepl("xgb", var) | grepl("vote", var))) %>%
        arrange(nchar(var))
#reorder
order = c("female", "pid_3way","age_bucket", "race", "region", "educ_6way", "income_5way",
                  "relig_6way",
                  "pid_race", "educ_pid",
                  "educ_pid_race", "race_educ_reg", "educ_wh_3way", "midwest_wh_edu",
                  "midwest_edu_race", 
                  "agesq", "age_factor")
wmabserr_nooutcomes <- wmabserr_nooutcomes[as.numeric(sapply(order, function(x) which(wmabserr_nooutcomes$var == x))),]
     
#kable aethetetics:
noedu_aes <- sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(formula_rake_demos_noeduc)[2]),
               "gray", "black") })
wedu_aes <-  sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(formula_rake_demos_weduc)[2])| x == "educ_6way", "gray", "black")
    })
all_aes <-  sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(formula_rake_all_vars)[2])| x == "educ_6way" , "gray", "black")
    })

selection_model = as.formula(~recode_female:recode_pid_3way + recode_age:recode_pid_3way + recode_race:recode_region:recode_educ_wh_3way:recode_pid_3way + recode_age + I(recode_age^2))

truth_aes <-  sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(selection_model)[2]) | x == "agesq", "gray", "black")
    })
ps_aes <- sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(formula_ps)[2]), "gray", "black") })
ps_reduc_aes <- sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(formula_ps_reduc)[2]) & x!= "race" , "gray", "black") })
ps_all_aes <- sapply(wmabserr_nooutcomes$var, function(x) {
        ifelse(grepl(x, as.character(formula_ps_all)[2]), "gray", "black") })

kpop_demos_aes <- noedu_aes
kpop_demos_wedu_aes <- wedu_aes
kpop_all_aes <- all_aes


#change name so its clear that recode_educ is 6 way and fixing some labels that are slighly off bc i apparently could not count when i named them/less cleaning in latex names
wmabserr$var[wmabserr$var == "income_5way"]<- "income_6way"
wmabserr$var[wmabserr$var == "relig_6way"]<- "relig_5way"
wmabserr$var[wmabserr$var == "educ_wh_3way"]<- "educ_3way_wh"

wmabserr_nooutcomes$var[wmabserr_nooutcomes$var == "income_5way"]<- "income_6way"
wmabserr_nooutcomes$var[wmabserr_nooutcomes$var == "relig_6way"]<- "relig_5way"
wmabserr_nooutcomes$var[wmabserr_nooutcomes$var == "educ_wh_3way"]<- "educ_3way_wh"

pop_w_lab = ifelse(POPW, "w/ Pop Weights", "No Pop Weights")
kable_err <- kable(wmabserr_nooutcomes,
                           format = "latex",
                           caption = paste0("Simulations: Average Weighted Mean Abs Error across ", length(good), " simulations, b = argmax V(K), ", pop_w_lab),
                           booktabs = T,
                           digits = 2) %>% kable_styling() %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "kpop_demos"),
                            color =kpop_demos_aes) %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "rake_demos_noeduc"),
                            color = noedu_aes) %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "kpop_demos_wedu"),
                            color = kpop_demos_wedu_aes) %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "rake_demos_weduc"),
                                              color = wedu_aes) %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "rake_all"),
                            color =all_aes) %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "kpop_all"),
                            color =kpop_all_aes) %>%
                    column_spec(which(colnames(wmabserr_nooutcomes) == "rake_truth"),
                            color =truth_aes) %>% 
                    column_spec(which(colnames(wmabserr_nooutcomes) == "post_strat_reduc"),
                                              color =ps_reduc_aes)



#other margins/outcomes
 kable_om <- kable(wmabserr %>% 
                          filter( #(var %in% c("age", "agesq", "agecubed") |
                                      grepl("mod", var) | grepl("xgb", var)|
                                      grepl("vote", var)) %>% arrange(nchar(var)),
                       format = "latex",
                       caption =  paste0("Simulations: Average Weighted MAE on Outcomes across ", length(good), " simulations, b = argmax V(K), ", pop_w_lab),
                       booktabs = T,
                       digits = 2)



```



### Plot Estimates
```{r results_plot, echo = FALSE, fig.align="center"}
plot_lasso_margin <- plot %>% 
    dplyr::select(unweighted, 
                  rake_demos_noeduc,
                  rake_demos_weduc,
                  rake_all,
                  #post_stratification,
                  post_strat_reduc,
                  #post_strat_all,
                  rake_truth,
                  kpop, 
                  #kpop_conv,
                  #kpop_mf, 
                  kpop_demos,
                  kpop_demos_wedu,
                  kpop_all) %>% 
  pivot_longer(everything(),
               names_to = "estimator", 
               values_to = "margin") %>%
  mutate(margin = (0.5 - margin) * 2 * 100,
         estimator_name = factor(case_when(estimator == "kpop" ~ "KPop",
                       estimator == "kpop_mf" ~ "Kpop aMF (All)",
                       estimator == "kpop_conv" ~ "Kpop Converged",
                       estimator == "kpop_demos" ~ "Kpop MF (Demos)",
                       estimator == "kpop_demos_wedu" ~ "Kpop MF (Demos+Edu)",
                       estimator == "kpop_all" ~ "Kpop MF (All)",
                       estimator == "rake_demos_noeduc" ~ "Raking\nDemos (No Educ)",
                       estimator == "rake_demos_weduc" ~ "Raking\nDemos (w/ Educ)",
                       estimator == "rake_all" ~ "Raking\n All",
                       estimator == "rake_truth" ~ "Raking\nTrue Selection\nModel",
                       estimator == "post_stratification" ~ "Post-Strat Prev",
                       estimator == "post_strat_reduc" ~ "Post-Strat Reduc",
                       estimator == "post_strat_all" ~ "Post-Strat All",
                       estimator == "unweighted" ~ "Unweighted"),
                    levels = c("Unweighted", 
                               "Raking\nDemos (No Educ)",
                               "Raking\nDemos (w/ Educ)",
                               "Raking\n All",
                               "Post-Strat Prev", 
                               "Post-Strat Reduc", 
                               "Post-Strat All",
                               "KPop",
                               "Kpop Converged",
                               "Kpop aMF (All)",
                               "Kpop MF (Demos)",
                               "Kpop MF (Demos+Edu)",
                               "Kpop MF (All)",
                               "Raking\nTrue Selection\nModel"
                               )))
View(plot_lasso_margin)


margin_sim <- (0.5 - mean(cces$recode_vote_2016_sim))*2*100

#### xgb diff cces and pew
ggplot(data = plot_lasso_margin,
       aes(x = estimator_name, y = margin)) +
  geom_boxplot(alpha = 0.2) +
  geom_hline(yintercept = margin_sim) +
  theme_bw() +
  ggtitle(paste0("Sim Results: lasso(lambda 1se)\n",
                 " ", "pop weights: ", POPW, "\n",length(good), " sims, b=maxvar")) +
  xlab("Estimator") +
  ylab("Lasso Simulated Vote Margin") +
  annotate(geom = "text", x = 0.5, y = margin_sim,
           label = "True\nTarget\nPopulation\nMargin", hjust = 0) +
  theme(panel.grid.major.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))


ggsave(file = paste0("./cat_sims_b_maxvar_4-07_dat_slim.pdf"), height = 4, width = 6)



```


```{r results_table, echo = FALSE}
## Table
#lasso
kable(
  plot_lasso_margin %>% 
    mutate(estimator_name = gsub("\n", " ", estimator_name)) %>%
    group_by(estimator_name) %>%
  summarize(truth = margin_sim,
            mest = mean(margin),
            mse = mean((margin - margin_sim)^2),
            bias = mean(margin - margin_sim),
            se = sd(margin),
            mae = mean(abs(margin - margin_sim))) %>%
  mutate(mse_ratio = mse / mse[estimator_name == "Unweighted"],
         bias_reduc = 1- bias / bias[estimator_name == "Unweighted"],
         se_ratio = se / se[estimator_name == "Unweighted"],
         mae_ratio = mae / mae[estimator_name == "Unweighted"]) %>%
  arrange(mse), caption = "Simulation Results (numeric)",
   format = "latex", digits = 4)


```





### BiasBound

```{r bb_scatterplot}
scatter_data <- plot %>% mutate(kpop_est = (0.5 - kpop)*2*100,
                                kpop_demos_est = (0.5 - kpop_demos)*2*100,
                                kpop_demos_wedu_est = (0.5 - kpop_demos_wedu)*2*100)

ggplot(scatter_data) +
  geom_point(aes(y = kpop_est, x = bbr, color =  "Kpop", #as.factor(b.i.), 
                 shape = "Kpop"), alpha = 0.4) +
  geom_point(aes(y = kpop_demos_est, x = bbr, color = "Kpop+MF (Demos)", #as.factor(b.i.), 
                 shape = "Kpop+MF (Demos)"), alpha = 0.4) +
  geom_point(aes(y = kpop_demos_wedu_est, x = bbr, color = "Kpop+MF (Demos+Edu)", #as.factor(b.i.), 
                 shape = "Kpop+MF (Demos+Edu)"), alpha = 0.4) +
  geom_hline(yintercept = margin_sim, linetype = 2) + 
  theme_bw() +
  xlab("Biasbound Ratio") +
  ylab("Vote Margin (lasso) Estimate") +
  ggtitle(paste0("Lasso: Estimates vs Biasbound Ratio\n", " POPW: ", POPW, " n=", length(good)))


```
